services:
  postgres:
    image: postgres:15-alpine
    container_name: aurite_postgres
    environment:
      POSTGRES_USER: ${AURITE_DB_USER:-postgres_user} # Use .env or default
      POSTGRES_PASSWORD: ${AURITE_DB_PASSWORD:-postgres_password} # Use .env or default
      POSTGRES_DB: ${AURITE_DB_NAME:-aurite_storage}   # Use .env or default
    volumes:
      - postgres_data:/var/lib/postgresql/data
    # ports: # Not exposing to host by default to avoid conflicts
      # - "${POSTGRES_HOST_PORT:-5432}:5432"
    networks:
      - aurite_network
    restart: unless-stopped

  backend:
    build:
      context: .
      dockerfile: Dockerfile.public
    container_name: aurite_backend
    ports:
      - "${PORT:-8000}:8000"
    volumes:
      # Mount the project directory to /app/project (where Dockerfile.public expects it)
      - .:/app/project
    env_file:
      - .env # Load environment variables from .env file
    environment:
      # Use file-based mode for testing (default for most users)
      AURITE_ENABLE_DB: "true"
      # Database configuration (available if user wants to enable it)
      AURITE_DB_TYPE: postgres
      AURITE_DB_HOST: postgres  # Use the postgres service name
      AURITE_DB_USER: ${AURITE_DB_USER:-postgres_user}
      AURITE_DB_PASSWORD: ${AURITE_DB_PASSWORD:-postgres_password}
      AURITE_DB_NAME: ${AURITE_DB_NAME:-aurite_storage}
      # API configuration
      API_KEY: ${API_KEY}
      # Docker environment flag
      DOCKER_ENV: "true"
      # Override the default production ENV from Dockerfile.public for development
      ENV: ${ENV:-development}
      # Cache directory (using container's cache, not project)
      CACHE_DIR: /app/cache
    depends_on:
      - postgres
    networks:
      - aurite_network
    extra_hosts:
      - "host.docker.internal:host-gateway" # Map host.docker.internal to the host's IP
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: aurite_studio
    ports:
      - "3000:3000" # Aurite Studio runs on port 3000
    volumes:
      # Mount the entire frontend directory to support monorepo structure and hot-reloading
      - ./frontend:/app
      # Use a named volume for node_modules to prevent the host's node_modules from overwriting the container's.
      - frontend_node_modules:/app/node_modules
    environment:
      # Variables for the React app inside the container
      # The React app runs in the browser, so it needs to connect to the backend via the host
      - REACT_APP_API_BASE_URL=http://localhost:8000
      - REACT_APP_API_KEY=${API_KEY} # Use API_KEY from the .env file
    depends_on:
      - backend
    networks:
      - aurite_network
    restart: unless-stopped

networks:
  aurite_network:
    driver: bridge

volumes:
  postgres_data:
    driver: local
  frontend_node_modules:
    driver: local
